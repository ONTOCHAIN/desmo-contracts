pragma solidity ^0.6.0;
pragma experimental ABIEncoderV2;

import "@iexec/doracle/contracts/IexecDoracle.sol";
import "@iexec/solidity/contracts/ERC1154/IERC1154.sol";
import "@iexec/solidity/contracts/ERC2362/IERC2362.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import "./DesmoHub.sol";

contract Desmo is Ownable, IexecDoracle, IOracleConsumer {
    struct QueryResult {
        bytes32 requestID;
        bytes32 taskID;
        bytes1[] scores;
        bytes result;
    }

    struct Request {
        bytes32 id;
        string[] selectedTDDsURLs;
        address[] selectedAddresses;
    }
    
    // -- State --
     // Request ID counter
    uint256 internal requestIdCounter = 0;
    // Size of the TDD lists to be selected
    uint256 internal tddSelectionSize = 4;
    uint256 internal selectionIndex = 0;
    // Record of the requests generated by the oracle
    mapping (bytes32 => Request) internal requests;

    mapping(bytes32 => bytes32) private requestIDtoTaskID;
    mapping(bytes32 => QueryResult) private values;

    mapping(bytes32 => uint256) private reputations;

    DesmoHub private desmoHub;

    // -- Events --

    event QueryCompleted(bytes32 indexed id, QueryResult result);
    event RequestCreated(bytes32 indexed requestID, Request request);

    // -- Functions --

    /**
     * @dev Desmo Contract Constructor
     */
    constructor(address desmoHubAddress, address iexecproxy)
        public
        IexecDoracle(iexecproxy)
    {
        desmoHub = DesmoHub(desmoHubAddress);
        desmoHub.setScoreManager(address(this));
    }

    /**
     * @dev Retrieve the query result using the generated iExec TaskID
     */
    function getQueryResult(bytes32 taskID)
        public
        view
        returns (QueryResult memory result)
    {
        return values[taskID];
    }

    /**
     * @dev Retrieve the query result using the request ID generated using
     * DesmoHub.getNewRequestID();
     */
    function getQueryResultByRequestID(bytes32 requestID)
        public
        view
        returns (QueryResult memory result)
    {
        return values[requestIDtoTaskID[requestID]];
    }

    /**
     * @dev retrive the current score for one
     */
    function getTDDReputation(address tddAddress) public view returns (uint256 score) {
        return reputations[0x626c756500000000000000000000000000000000000000000000000000000000];
    }

    /**
     * @dev Update the iExec variables
     */
    function updateEnv(
        address authorizedApp,
        address authorizedDataset,
        address authorizedWorkerpool,
        bytes32 requiredtag,
        uint256 requiredtrust
    ) public onlyOwner {
        _iexecDoracleUpdateSettings(
            authorizedApp,
            authorizedDataset,
            authorizedWorkerpool,
            requiredtag,
            requiredtrust
        );
    }

    /**
    * @dev Generate a new Request selecting a subset of TDDs. The ID can be later used to retrieve the list of selected TDDs.
           The generated request ID is emitted as an event toghert with the list of selected TDDs.
    */
    function generateNewRequestID() public returns (bytes32) {
        bytes32 key = bytes32(requestIdCounter);
        uint256 tddsLeft = tddSelectionSize;
        uint256 tddListSize = desmoHub.getEnabledTDDsStorageLength();
        
        if(tddListSize < 1) {
            revert("No TDDs available");
        }

        uint256 index = selectionIndex % tddListSize;

        if(tddsLeft > tddListSize) {
            tddsLeft = tddListSize;
        }

        uint selectionSize = tddsLeft;
        Request memory request = Request(key, new string[](selectionSize), new address[](selectionSize));

        while(tddsLeft > 0){
            request.selectedAddresses[selectionSize - tddsLeft] = desmoHub.getEnabledTDDByIndex(index).owner;
            request.selectedTDDsURLs[selectionSize - tddsLeft] = desmoHub.getEnabledTDDByIndex(index).url;
            index = (index + 1) % tddListSize;
            tddsLeft--;
        }

        selectionIndex = index;
        requestIdCounter += 1;
        requests[key] = request;
        emit RequestCreated(key, request);
        return key;      
    }

    /**
     * @dev Retrieve the final computation result for you query.
     * The function emits the QueryCompleted event.
     */
    function receiveResult(bytes32 taskID, bytes memory data)
        external
        override
    {
        bytes memory results = _iexecDoracleGetVerifiedResult(taskID);
        values[taskID] = _processQueryResult(taskID, results);
        bytes1[] memory scores = values[taskID].scores;
        Request memory originalRequest = requests[values[taskID].requestID];
            
        reputations[0x626c756500000000000000000000000000000000000000000000000000000000] = 1;

        emit QueryCompleted(taskID, values[taskID]);
    }
        
    function _processQueryResult(bytes32 taskID, bytes memory payload)
        internal
        pure
        returns (QueryResult memory result)
    {
        uint8 requestIDLength;
        uint8 scoreAmount;
        bytes32 requestID;

        
        requestIDLength = uint8(bytes1(payload[0]));
        
        if( requestIDLength != 32 ) {
            revert("Invalid request ID length; expected 32 bytes");
        }

        requestID = _bytesToBytes32(payload,1);

        scoreAmount = uint8(bytes1(payload[requestIDLength + 1]));
        bytes1[] memory resultScores = new bytes1[](scoreAmount);
        
        for(uint8 i = 0; i < scoreAmount; i++) {
            bytes1 score = bytes1(payload[requestIDLength + 2 + i]);
            resultScores[i] = score;
        }

        bytes memory queryResult = new bytes(payload.length - requestIDLength - 2 - scoreAmount);
        for(uint8 i = 0; i < queryResult.length; i++) {
            queryResult[i] = payload[requestIDLength + 2 + scoreAmount + i];
        }

        return QueryResult(requestID, taskID, resultScores, queryResult);
    }

    function _bytesToBytes32(bytes memory b, uint256 offset)
        internal
        pure
        returns (bytes32)
    {
        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {
            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
        }

        return out;
    }
}
